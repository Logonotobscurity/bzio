## B2B PLATFORM STRUCTURAL ANALYSIS

### 1. DATABASE SCHEMA

The Prisma schema defines the following core models and relationships:

**1. Main Tables:**
*   **Users/Customers:** The `User` table stores customer information, including `email`, `passwordHash`, `firstName`, `lastName`, `phone`, `companyName`, and `role` (`customer`, `admin`).
*   **Products:** The `Product` table holds the customer-facing catalog with fields like `sku`, `slug`, `name`, `description`, `price`, `inStock`, `isFeatured`, `moq` (Minimum Order Quantity), and `images`.
*   **Quotes/Quote Requests:** A `Quote` table exists with a `uuid`, a user relationship, `status` (e.g., 'draft', 'submitted'), and line items. The `QuoteLine` table details the products and quantities in each quote. There is also a `NegotiationMessage` table, suggesting a messaging feature is tied to quotes.
*   **Orders:** There is **NO** dedicated `Order` table. The current workflow seems to terminate at the `Quote` stage. Orders are likely a conceptual extension of a confirmed quote.
*   **Payments:** There is **NO** `Payment` table.
*   **Categories/Brands:**
    *   `Category`: Stores product categories (`name`, `slug`).
    *   `Brand`: Stores brand information (`name`, `slug`).
    *   `Company`: Represents the manufacturer or parent company of brands/products.

**2. Relationships:**
*   One `User` has many `Addresses` and many `Quotes`.
*   One `Brand` has many `Products`.
*   One `Company` has many `Brands` and many `Products`.
*   One `Product` belongs to one `Brand` and one `Company`.
*   A `Product` can belong to many `Categories` through the `ProductCategory` join table.
*   One `Quote` has many `QuoteLines`.

**3. Sensitive Data:**
*   **`User` table:** `passwordHash` must not be synced.
*   **`Address` table:** Contains PII (Personally Identifiable Information) like contact person, phone, and address lines. Syncing should be based on business requirements.

**4. Unique Identifiers:**
*   **`User`, `Product`, `Category`, `Brand`:** Use auto-incrementing integers (`id`). They also have a `slug` for user-friendly URLs.
*   **`Quote`, `QuoteLine`:** Use UUIDs for the `id` field. Quotes also have a unique `reference` string.

---

### 2. API STRUCTURE

Based on the Next.js App Router structure and best practices, the API endpoints are likely organized as follows:

**1. API Routes:**
*   `/api/auth/[...nextauth]`: For handling authentication (login, logout, session management).
*   `/api/products`: For listing products (with filtering/pagination).
*   `/api/products/[slug]`: For retrieving a single product's details.
*   `/api/quote`: For creating and managing quotes (e.g., `POST` to create, `GET` to retrieve user's quotes).
*   `/api/quote/[id]`: For actions on a specific quote (updating lines, submitting).
*   `/api/categories`: For listing product categories.
*   `/api/brands`: For listing brands.

**2. API Authentication:**
*   APIs use **NextAuth.js sessions**. The user's session cookie is used to authorize requests for protected resources like creating a quote or viewing account details.

**3. Webhook Endpoints:**
*   There are no dedicated incoming webhook endpoints visible in the current structure, besides what NextAuth might use internally.

**4. Rate Limiting:**
*   Yes, rate limiting is implemented using `@upstash/ratelimit`, likely on sensitive endpoints like authentication and form submissions to prevent abuse.

---

### 3. AUTHENTICATION SYSTEM

**1. Customer Registration/Login:**
*   Primarily **Email/password**. The schema includes `passwordHash` and `emailVerified` fields.

**2. User Roles:**
*   **`customer`**: The default role for retailers.
*   **`admin`**: For internal management of the platform.

**3. Session Storage:**
*   NextAuth.js with a database adapter (`@auth/prisma-adapter`) stores session information in the **database**. This includes tables like `Session`, `Account`, and `VerificationToken` (though not explicitly shown in the provided schema, they are standard for the adapter).

**4. Email Verification:**
*   **Yes**, the `emailVerified` field in the `User` model and the `resend` integration confirm that email verification is part of the workflow.

**5. Password Policies:**
*   Not explicitly defined in the schema, but would be enforced at the application level (e.g., minimum length, complexity).

---

### 4. FRONTEND STRUCTURE

**1. Main Page Routes:**
*   `/`: Homepage
*   `/products`: Product listing/catalog page.
*   `/products/[slug]`: Product detail page.
*   `/quote`: The main page for the quoting system, likely showing the current quote draft.
*   `/account`: Customer portal for managing profile, addresses, and viewing quote history.
*   `/login`: Login page.
*   `/register`: Registration page.

**2. State Management:**
*   **Zustand**: Used for global state management. Likely stores for `cart/quote`, `user session`, and `UI state` (e.g., modal open/closed).
*   **React Context**: Potentially used for theme or other top-level providers.

**3. UI Components:**
*   **shadcn/ui**: This is the primary component library. Components used would include `Button`, `Card`, `Input`, `Table`, `Dialog`, `Select`, `Toast`, etc.
*   **Custom Components**: Built on top of shadcn/ui for specific business logic (e.g., `ProductCard`, `QuoteRequestForm`).

**4. Data Fetching:**
*   A mix of methods is likely used:
    *   **Server-Side Rendering (or Server Components in App Router)**: For dynamic, user-specific data like the `/account` page.
    *   **Static Site Generation (SSG)**: For product pages (`/products/[slug]`) that can be pre-built for performance, with revalidation to keep them fresh.
    *   **Client-Side Fetching**: For interactive components like search bars or when updating the quote without a page reload.

---

### 5. BUSINESS WORKFLOWS

**1. Quote Request Flow:**
*   Customer browses products → Clicks "Add to Quote" → Items are added to a draft quote state (managed by Zustand) → Customer navigates to the `/quote` page, reviews items and quantities → Clicks "Submit Quote".
*   **After Submission:** The status of the `Quote` in the database is updated to `submitted`. An email notification is sent to the customer via Resend, and an internal notification is likely triggered for the sales team.

**2. Order Placement Flow:**
*   This flow is **not fully implemented**. There are no "Orders" or "Payments". The process stops after a quote is submitted. The expected flow would be for the sales team to handle the quote offline or in the BZION HUB, and then manually update its status.

**3. Order Tracking:**
*   Customers can likely track the **status of their quote** (`draft`, `submitted`, `in-review`, `approved`), but not an "order" in the traditional sense.

**4. Customer Account Management:**
*   Customers can:
    *   View their quote history.
    *   Update their profile information (`firstName`, `lastName`, `companyName`).
    *   Manage shipping and billing addresses.

---

### 6. INTEGRATION POINTS

**1. Payment Processing:**
*   **Currently**: None.
*   **Planned**: This is a critical missing piece for a full e-commerce workflow.

**2. Email Service:**
*   **Currently**: **Resend**.
*   **Templates for**: User Registration, Email Verification, Quote Submission Confirmation.

**3. Analytics & Error Tracking:**
*   **Currently**: None configured, although analytics models like `ProductView` and `SearchQuery` exist for internal tracking. An `ErrorLog` model exists, but a third-party service like Sentry is not integrated.

---

### SPECIFIC EXAMPLES

### Example 1: Quote Table Structure
There is no `orders` table. Here is the equivalent structure for the `quotes` table based on your schema:

```sql
-- SQL representation of the Prisma 'Quote' model
CREATE TABLE "Quote" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "reference" TEXT NOT NULL,
    "user_id" INTEGER,
    "buyerContactEmail" TEXT,
    "status" TEXT NOT NULL DEFAULT 'draft', -- Values: 'draft', 'submitted', 'in-review', 'approved', 'rejected'
    "total" DOUBLE PRECISION,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Quote_reference_key" UNIQUE ("reference"),
    CONSTRAINT "Quote_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE
);

CREATE TABLE "QuoteLine" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "quoteId" TEXT NOT NULL,
    "productId" TEXT,
    "qty" INTEGER NOT NULL,
    "unitPrice" DOUBLE PRECISION,
    "productName" TEXT NOT NULL,
    "productSku" TEXT,
    "description" TEXT,

    CONSTRAINT "QuoteLine_quoteId_fkey" FOREIGN KEY ("quoteId") REFERENCES "Quote"("id") ON DELETE CASCADE ON UPDATE CASCADE
);
```

### Example 2: API Response Format

```json
// Example response for GET /api/products/mamador-oil
{
  "endpoint": "/api/products/mamador-oil",
  "method": "GET",
  "response": {
    "id": 12,
    "sku": "MAM-OIL-25L",
    "slug": "mamador-oil",
    "name": "Mamador Vegetable Oil",
    "description": "Pure vegetable oil, great for all cooking purposes.",
    "price": 45000.00,
    "inStock": true,
    "moq": 5,
    "unit": "25L Keg",
    "images": [
      { "url": "/images/products/mamador-oil.jpg", "alt": "Mamador Oil" }
    ],
    "brand": {
      "name": "Mamador"
    }
  }
}
```

### Example 3: Webhook Payload (for BZION HUB)

This is a **proposed** webhook payload that your system would send to BZION HUB when a quote is submitted.

```json
{
  "event": "quote.submitted",
  "timestamp": "2024-05-21T14:00:00Z",
  "data": {
    "quote_id": "c3e4a1d8-a2f8-4b9f-8c3e-9b6d8f8a7e0a",
    "quote_reference": "Q-2024-54321",
    "customer": {
      "id": 42,
      "email": "retailer@example.com",
      "company_name": "SuperMart Nigeria"
    },
    "items": [
      {
        "sku": "MAM-OIL-25L",
        "name": "Mamador Vegetable Oil",
        "quantity": 10
      },
      {
        "sku": "IND-NOOD-70G-CTN",
        "name": "Indomie Noodles (Carton)",
        "quantity": 50
      }
    ],
    "submitted_at": "2024-05-21T14:00:00Z"
  }
}
```
